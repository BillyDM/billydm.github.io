<!DOCTYPE html>
<html lang="en">

<head>
    
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
<title>Safe (and Fast) Audio Buffer API in Rust - Billy Messenger</title>

    
    <link rel="stylesheet" href="/css/simple.min.css">
    
    
<style>
.toc {
    margin-bottom: 3rem;
}
</style>

    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <link rel="alternate" type="application/atom+xml" title="Atom Feed for billydm.github.io" href="/atom.xml" />
    <link rel="preconnect" href="https://api.fonts.coollabs.io" crossorigin>
    <link href="https://api.fonts.coollabs.io/css2?family=Inter&display=swap" rel="stylesheet">
    <link href="https://api.fonts.coollabs.io/css2?family=Fira+Code&display=swap" rel="stylesheet">
    
    
    
    
</head>

<body>
    <header>
        
        <nav>
            
            <a href="&#x2F;">Home</a>
            
            <a href="&#x2F;blog&#x2F;">Blog</a>
            
            <a href="&#x2F;categories&#x2F;">Categories</a>
            
            <a href="&#x2F;atom.xml">Feed</a>
            
            <a href="https:&#x2F;&#x2F;github.com&#x2F;BillyDM">Github</a>
            
        </nav>
        
        
<h1>Safe (and Fast) Audio Buffer API in Rust</h1>

    </header>
    
    <main>
        
<article>
    
    <em>Published on: <time>31 Mar 2022</time></em>
    
    
    <h2>Table of Contents</h2>
    <ul class="toc">
        
        <li>
            <a href="https://billydm.github.io/blog/audio-buffer-api/#dealing-with-mixed-32-bit-and-64-bit-buffers">Dealing with mixed 32 bit and 64 bit buffers</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/audio-buffer-api/#dealing-with-aliasing-pointers">Dealing with aliasing pointers</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/audio-buffer-api/#actual-implementation">Actual implementation</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/audio-buffer-api/#to-be-continued">To be continued</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/audio-buffer-api/#addendum">Addendum</a>
            
        </li>
        
    </ul>
    
    
    <blockquote>
<p>UPDATE: I'm not really happy with this article anymore. I've ended up not actually using this code, and there are many things I would change about it today (including removing the unsafe). I may update this at some point, but I'm busy with other things right now.</p>
</blockquote>
<hr />
<p>While writing my DAW engine in Rust, I've came across a very Rust-specific problem when it comes to audio buffers for plugins.</p>
<p>I plan on having first-class support for the awesome new open-source <a href="https://github.com/free-audio/clap">CLAP</a> plugin spec (although this problem isn't specific to that spec). In it, the host sends the audio buffers to the plugin in a couple of small and tidy structs:</p>
<pre data-lang="c" style="background-color:#282828;color:#fdf4c1aa;" class="language-c "><code class="language-c" data-lang="c"><span style="font-style:italic;color:#928374;">// C
</span><span>
</span><span style="color:#fa5c4b;">typedef struct</span><span> clap_process {
</span><span>   </span><span style="font-style:italic;color:#928374;">// ...
</span><span>
</span><span>   </span><span style="font-style:italic;color:#928374;">// Audio buffers, they must have the same count as specified
</span><span>   </span><span style="font-style:italic;color:#928374;">// by clap_plugin_audio_ports-&gt;get_count().
</span><span>   </span><span style="font-style:italic;color:#928374;">// The index maps to clap_plugin_audio_ports-&gt;get_info().
</span><span>   </span><span style="font-style:italic;color:#928374;">//
</span><span>   </span><span style="font-style:italic;color:#928374;">// If a plugin does not implement clap_plugin_audio_ports,
</span><span>   </span><span style="font-style:italic;color:#928374;">// then it gets a default stereo input and output.
</span><span>   </span><span style="color:#fa5c4b;">const</span><span> clap_audio_buffer_t </span><span style="color:#fe8019;">*</span><span>audio_inputs;
</span><span>   clap_audio_buffer_t       </span><span style="color:#fe8019;">*</span><span>audio_outputs;
</span><span>   </span><span style="color:#fabd2f;">uint32_t</span><span>                   audio_inputs_count;
</span><span>   </span><span style="color:#fabd2f;">uint32_t</span><span>                   audio_outputs_count;
</span><span>
</span><span>   </span><span style="font-style:italic;color:#928374;">// ...
</span><span>} </span><span style="color:#8ec07c;">clap_process_t</span><span>;
</span><span>
</span><span style="color:#fa5c4b;">typedef struct</span><span> clap_audio_buffer {
</span><span>   </span><span style="font-style:italic;color:#928374;">// Either data32 or data64 pointer will be set.
</span><span>   </span><span style="color:#fa5c4b;">float  </span><span style="color:#fe8019;">**</span><span>data32;
</span><span>   </span><span style="color:#fa5c4b;">double </span><span style="color:#fe8019;">**</span><span>data64;
</span><span>   </span><span style="color:#fabd2f;">uint32_t</span><span> channel_count;
</span><span>   </span><span style="color:#fabd2f;">uint32_t</span><span> latency;       </span><span style="font-style:italic;color:#928374;">// latency from/to the audio interface
</span><span>   </span><span style="color:#fabd2f;">uint64_t</span><span> constant_mask; </span><span style="font-style:italic;color:#928374;">// mask &amp; (1 &lt;&lt; N) to test if channel N is
</span><span>                           </span><span style="font-style:italic;color:#928374;">// constant
</span><span>} </span><span style="color:#8ec07c;">clap_audio_buffer_t</span><span>;
</span></code></pre>
<p>All fine and dandy, but a couple conundrums arise with the how the plugin is allowed to define what buffers it wants for each of its audio ports:</p>
<pre data-lang="c" style="background-color:#282828;color:#fdf4c1aa;" class="language-c "><code class="language-c" data-lang="c"><span style="font-style:italic;color:#928374;">// C
</span><span>
</span><span style="color:#fa5c4b;">enum </span><span>{
</span><span>   </span><span style="font-style:italic;color:#928374;">// This port is the main audio input or output.
</span><span>   </span><span style="font-style:italic;color:#928374;">// There can be only one main input and main output.
</span><span>   </span><span style="font-style:italic;color:#928374;">// Main port must be at index 0.
</span><span>   CLAP_AUDIO_PORT_IS_MAIN </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1 </span><span style="color:#fe8019;">&lt;&lt; </span><span style="color:#d3869b;">0</span><span>,
</span><span>
</span><span>   </span><span style="font-style:italic;color:#928374;">// The prefers 64 bits audio with this port.
</span><span>   CLAP_AUDIO_PORTS_PREFERS_64BITS </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1 </span><span style="color:#fe8019;">&lt;&lt; </span><span style="color:#d3869b;">1</span><span>,  </span><span style="font-style:italic;color:#928374;">// &lt;----------------- 1
</span><span>};
</span><span>
</span><span style="color:#fa5c4b;">typedef struct</span><span> clap_audio_port_info {
</span><span>   </span><span style="font-style:italic;color:#928374;">// ...
</span><span>
</span><span>   </span><span style="color:#fabd2f;">uint32_t</span><span> flags;
</span><span>   </span><span style="color:#fabd2f;">uint32_t</span><span> channel_count;
</span><span>
</span><span>   </span><span style="font-style:italic;color:#928374;">// ...
</span><span>
</span><span>   </span><span style="font-style:italic;color:#928374;">// in-place processing: allow the host to use the same buffer for
</span><span>   </span><span style="font-style:italic;color:#928374;">// input and output if supported set the pair port id.
</span><span>   </span><span style="font-style:italic;color:#928374;">// if not supported set to CLAP_INVALID_ID
</span><span>   clap_id in_place_pair;  </span><span style="font-style:italic;color:#928374;">// &lt;----------------------------------- 2
</span><span>} </span><span style="color:#8ec07c;">clap_audio_port_info_t</span><span>;
</span></code></pre>
<ol>
<li>Each audio port can choose whether it wants to use 32 bit or 64 bit buffers. This means you can have plugins that requests 32 bit buffers for some ports and 64 bit buffers for others. To make matters more complicated, this only hints to the host that the plugin <em>wants</em> 64 bit buffers, but the host may still give it 32 bit buffers regardless. Luckily on the flipside the host may not send 64 bit buffers to plugins that haven't requested it.</li>
<li>Any pair of input and output ports may be bounded together into their own "in_place_pair". This tells the host that it may send a single buffer for both ports in that pair to save CPU resources, akin to <code>process_replacing()</code> in VST.</li>
</ol>
<h1 id="dealing-with-mixed-32-bit-and-64-bit-buffers">Dealing with mixed 32 bit and 64 bit buffers</h1>
<hr />
<p>To start with the first problem, we can use an enum for <code>clap_audio_buffer_t</code> that can either be 32 bit or 64 bit buffers:</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#928374;">// Rust
</span><span>
</span><span style="color:#fa5c4b;">pub enum </span><span style="color:#8ec07c;">AudioBuffer </span><span>{
</span><span>    </span><span style="color:#fdf4c1;">F32</span><span>(</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fa5c4b;">f32</span><span>&gt;&gt;),
</span><span>    </span><span style="color:#fdf4c1;">F64</span><span>(</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fa5c4b;">f64</span><span>&gt;&gt;),
</span><span>}
</span></code></pre>
<p>Fine enough for plugins that requested 64 bit buffers, but for plugins that haven't made that request, we are requiring them to essentially add a runtime check for something that is guaranteed to be the 32 bit variant. This runtime check may not be a big deal for most plugins, but I would like to have the ability to avoid it if possible. The solution I came up with is to use the <code>unwrap_unchecked</code> option built into Rust's <code>Option</code> type:</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#928374;">// Rust
</span><span>
</span><span style="color:#fa5c4b;">pub struct </span><span style="color:#8ec07c;">AudioBuffer </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">float</span><span>: </span><span style="color:#fabd2f;">Option</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fa5c4b;">f32</span><span>&gt;&gt;&gt;,
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">double</span><span>: </span><span style="color:#fabd2f;">Option</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fa5c4b;">f64</span><span>&gt;&gt;&gt;,
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// Ensure that this struct can only be initialized with
</span><span>    </span><span style="font-style:italic;color:#928374;">// `new_f32()` or `new_f64()`.
</span><span>    </span><span style="color:#fdf4c1;">_private</span><span>: (),
</span><span>}
</span><span>
</span><span style="color:#fa5c4b;">impl </span><span style="color:#8ec07c;">AudioBuffer </span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// These initializers ensure that either `float` or `double` will
</span><span>    </span><span style="font-style:italic;color:#928374;">// always be `Some`.
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">new_f32</span><span>(</span><span style="color:#fdf4c1;">float</span><span>: </span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fa5c4b;">f32</span><span>&gt;&gt;) -&gt; </span><span style="color:#fa5c4b;">Self </span><span>{
</span><span>        AudioBuffer { float: </span><span style="color:#fabd2f;">Some</span><span>(float), double: </span><span style="color:#fabd2f;">None</span><span>, _private: () }
</span><span>    }
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">new_f64</span><span>(</span><span style="color:#fdf4c1;">double</span><span>: </span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fa5c4b;">f64</span><span>&gt;&gt;) -&gt; </span><span style="color:#fa5c4b;">Self </span><span>{
</span><span>        AudioBuffer { float: </span><span style="color:#fabd2f;">None</span><span>, double: </span><span style="color:#fabd2f;">Some</span><span>(double), _private: () }
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#928374;">// --------------------------------------------------------------------
</span><span>
</span><span style="font-style:italic;color:#928374;">// Now the plugin that requested 64 bit buffers can retrieve them like
</span><span style="font-style:italic;color:#928374;">// this:
</span><span>
</span><span style="color:#fa5c4b;">if let </span><span style="color:#fabd2f;">Some</span><span>(b) </span><span style="color:#fe8019;">=</span><span> buffer.double.</span><span style="color:#fabd2f;">as_mut</span><span>() {
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// 64 bit dsp stuff
</span><span>
</span><span>} </span><span style="color:#fa5c4b;">else </span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// The user can safely use `unwrap_unchecked()` here because if
</span><span>    </span><span style="font-style:italic;color:#928374;">// `double` is `None` then `float` must be `Some`.
</span><span>    </span><span style="font-style:italic;color:#928374;">//
</span><span>    </span><span style="font-style:italic;color:#928374;">// Or they can still use the `if let Some()` trick if they don&#39;t
</span><span>    </span><span style="font-style:italic;color:#928374;">// want any unsafe in their code, at the cost of an extra runtime
</span><span>    </span><span style="font-style:italic;color:#928374;">// check.
</span><span>    </span><span style="color:#fa5c4b;">let</span><span> b </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">unsafe </span><span>{ buffer.float.</span><span style="color:#fabd2f;">as_mut</span><span>().</span><span style="color:#fabd2f;">unwrap_unchecked</span><span>() };
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// 32 bit dsp stuff
</span><span>
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#928374;">// --------------------------------------------------------------------
</span><span>
</span><span style="font-style:italic;color:#928374;">// And plugins that have not requested 64 bit buffers can safely
</span><span style="font-style:italic;color:#928374;">// assume that the buffer is always 32 bit:
</span><span style="font-style:italic;color:#928374;">//
</span><span style="font-style:italic;color:#928374;">// Or they can still use the `if let Some()` trick if they don&#39;t
</span><span style="font-style:italic;color:#928374;">// want any unsafe in their code, at the cost of a runtime check.
</span><span>
</span><span style="color:#fa5c4b;">let</span><span> b </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">unsafe </span><span>{ buffer.float.</span><span style="color:#fabd2f;">as_mut</span><span>().</span><span style="color:#fabd2f;">unwrap_unchecked</span><span>() };
</span><span>
</span></code></pre>
<h1 id="dealing-with-aliasing-pointers">Dealing with aliasing pointers</h1>
<hr />
<p>In C and C++, the host sends a single buffer for an "in_place_pair" of ports by storing the same pointer in both slots. For example, the host can send a single stereo buffer to a plugin with a single input/output like this:</p>
<pre data-lang="c" style="background-color:#282828;color:#fdf4c1aa;" class="language-c "><code class="language-c" data-lang="c"><span style="font-style:italic;color:#928374;">// C
</span><span>
</span><span style="color:#fa5c4b;">float</span><span> left_buffer[MAX_FRAMES];
</span><span style="color:#fa5c4b;">float</span><span> right_buffer[MAX_FRAMES];
</span><span style="color:#fa5c4b;">float</span><span style="color:#fe8019;">*</span><span> stereo_buffer[</span><span style="color:#d3869b;">2</span><span>] </span><span style="color:#fe8019;">= </span><span>{</span><span style="color:#fe8019;">&amp;</span><span>left_buffer, </span><span style="color:#fe8019;">&amp;</span><span>right_buffer};
</span><span>
</span><span>clap_audio_buffer_t input_buffer </span><span style="color:#fe8019;">= </span><span>{
</span><span>    .</span><span style="color:#fdf4c1;">data32 </span><span style="color:#fe8019;">= &amp;</span><span>stereo_buffer,
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// ... initialize other stuff
</span><span>};
</span><span>
</span><span>clap_audio_buffer_t output_buffer </span><span style="color:#fe8019;">= </span><span>{
</span><span>    .</span><span style="color:#fdf4c1;">data32 </span><span style="color:#fe8019;">= &amp;</span><span>stereo_buffer,
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// ... initialize other stuff
</span><span>};
</span><span>
</span><span>clap_process_t proc </span><span style="color:#fe8019;">= </span><span>{
</span><span>    .</span><span style="color:#fdf4c1;">audio_inputs </span><span style="color:#fe8019;">= &amp;</span><span>input_buffer,
</span><span>    .</span><span style="color:#fdf4c1;">audio_outputs </span><span style="color:#fe8019;">= &amp;</span><span>output_buffer,
</span><span>    .</span><span style="color:#fdf4c1;">audio_inputs_count </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span>,
</span><span>    .</span><span style="color:#fdf4c1;">audio_outputs_count </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span>,
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// ... initialize other stuff
</span><span>}
</span></code></pre>
<p>This creates an aliased pointer to mutable data (the same pointer appears twice within the same struct). C and C++ are all hunky-dory with this, but Rust is not.</p>
<p>So how do we fix it in Rust?</p>
<p>After a lot of head-scratching and rewrites, I eventually came to this solution. Wrap all the input ports in an <code>Option</code>. If an input port is <code>None</code>, then it means that the host has given a single buffer for that input/output port pair. If that is the case then the shared buffer will live in the corresponding output port.</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#928374;">// Rust
</span><span>
</span><span style="color:#fa5c4b;">pub struct </span><span style="color:#8ec07c;">ProcAudioBuffers </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">inputs</span><span>: </span><span style="color:#fabd2f;">Vec</span><span>&lt;</span><span style="color:#fabd2f;">Option</span><span>&lt;AudioBuffer&gt;&gt;,
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">outputs</span><span>: </span><span style="color:#fabd2f;">Vec</span><span>&lt;AudioBuffer&gt;,
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#928374;">// --------------------------------------------------------------------
</span><span>
</span><span style="font-style:italic;color:#928374;">// Now a plugin that has requested in-place can check if a
</span><span style="font-style:italic;color:#928374;">// particular pair is in-place or not:
</span><span>
</span><span style="font-style:italic;color:#928374;">// As a side note, the user may also safely use `get_unchecked`
</span><span style="font-style:italic;color:#928374;">// for indexing into the array of buffers if the plugin has
</span><span style="font-style:italic;color:#928374;">// defined an input/output port at that index.
</span><span style="color:#fa5c4b;">let</span><span> output </span><span style="color:#fe8019;">= &amp;</span><span style="color:#fa5c4b;">mut</span><span> proc_buffers.outputs[</span><span style="color:#d3869b;">0</span><span>];
</span><span>
</span><span style="color:#fa5c4b;">if let </span><span style="color:#fabd2f;">Some</span><span>(input) </span><span style="color:#fe8019;">= &amp;</span><span>proc_buffers.inputs[</span><span style="color:#d3869b;">0</span><span>] {
</span><span>    </span><span style="font-style:italic;color:#928374;">// Non-in-place DSP stuff
</span><span>} </span><span style="color:#fa5c4b;">else </span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// In-place DSP stuff
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#928374;">// --------------------------------------------------------------------
</span><span>
</span><span style="font-style:italic;color:#928374;">// If a plugin has not put an input port in an &quot;in_place_pair&quot;,
</span><span style="font-style:italic;color:#928374;">// then the user may safely use `unwrap_unchecked()` to get that
</span><span style="font-style:italic;color:#928374;">// input port buffer without any checks at runtime.
</span><span>
</span><span style="color:#fa5c4b;">let</span><span> sidechain_in </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">unsafe </span><span>{
</span><span>    proc_buffers.inputs.</span><span style="color:#fabd2f;">as_ref</span><span>().</span><span style="color:#fabd2f;">get_unchecked</span><span>(</span><span style="color:#d3869b;">1</span><span>).</span><span style="color:#fabd2f;">unwrap_unchecked</span><span>()
</span><span>};
</span></code></pre>
<p>This may seem fairly simple in hindsight, but I only came to this solution once I accepted there is no clean way to get around making the user use <code>unsafe</code> to achieve the least possible amount of runtime checks. I've tried things like <a href="https://github.com/RustyDAW/rusty-daw-engine/blob/ddf260123ec69b41ef92e184f94ebfb8d42ce231/src/process_info/proc_audio_buffers.rs">complex enums</a> that tried to boil everything down into a single runtime check (switching on the enum), but it got ugly fast.</p>
<h1 id="actual-implementation">Actual implementation</h1>
<hr />
<p>One more note before I wrap this up. You might have noticed that the user has mutable access to the input buffers in <code>ProcAudioBuffers</code>.</p>
<p>First off, I should note that the buffers in my DAW engine aren't just <code>Vec</code>'s, they actually look like this:</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#928374;">// Rust
</span><span>
</span><span>#[</span><span style="color:#fdf4c1;">derive</span><span>(Clone)]
</span><span style="color:#fa5c4b;">pub</span><span>(</span><span style="color:#fa5c4b;">crate</span><span>) </span><span style="color:#fa5c4b;">struct </span><span style="color:#8ec07c;">SharedAudioBuffer</span><span>&lt;T&gt;
</span><span>where
</span><span>    T: Sized + Copy + Clone + Send + Default + &#39;static
</span><span>{
</span><span>    </span><span style="color:#fdf4c1;">buffer</span><span>: Shared&lt;(UnsafeCell&lt;</span><span style="color:#fabd2f;">Vec</span><span>&lt;T&gt;&gt;, UniqueBufferID)&gt;,
</span><span>}
</span><span>
</span><span style="color:#fa5c4b;">impl</span><span>&lt;T&gt; </span><span style="color:#8ec07c;">SharedAudioBuffer</span><span>&lt;T&gt;
</span><span style="color:#fa5c4b;">where
</span><span>    T: Sized + Copy + Clone + Send + Default + </span><span style="color:#fa5c4b;">&#39;static
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// ...
</span><span>
</span><span>    #[</span><span style="color:#fdf4c1;">inline</span><span>]
</span><span>    </span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">borrow</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>, </span><span style="color:#fdf4c1;">proc_info</span><span>: </span><span style="color:#fe8019;">&amp;</span><span>ProcInfo) -&gt; </span><span style="color:#fe8019;">&amp;</span><span>[T] {
</span><span>        </span><span style="color:#fa5c4b;">unsafe </span><span>{
</span><span>            std::slice::from_raw_parts(
</span><span>                (</span><span style="color:#fe8019;">*</span><span style="color:#fdf4c1;">self</span><span>.buffer.</span><span style="color:#d3869b;">0.</span><span style="color:#fabd2f;">get</span><span>()).</span><span style="color:#fabd2f;">as_slice</span><span>().</span><span style="color:#fabd2f;">as_ptr</span><span>(),
</span><span>                proc_info.frames
</span><span>            )
</span><span>        }
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#fdf4c1;">inline</span><span>]
</span><span>    </span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">borrow_mut</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>, </span><span style="color:#fdf4c1;">proc_info</span><span>: </span><span style="color:#fe8019;">&amp;</span><span>ProcInfo) -&gt; </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut </span><span>[T] {
</span><span>        </span><span style="color:#fa5c4b;">unsafe </span><span>{
</span><span>            std::slice::from_raw_parts_mut(
</span><span>                (</span><span style="color:#fe8019;">*</span><span style="color:#fdf4c1;">self</span><span>.buffer.</span><span style="color:#d3869b;">0.</span><span style="color:#fabd2f;">get</span><span>()).</span><span style="color:#fabd2f;">as_mut_slice</span><span>().</span><span style="color:#fabd2f;">as_mut_ptr</span><span>(),
</span><span>                proc_info.frames,
</span><span>            )
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Yes, that is an <code>UnsafeCell</code>. I won't get into detail an what this is all doing for now as I'll probably make another post about it in the near future, but for now you can read the <a href="https://github.com/RustyDAW/rusty-daw-engine/blob/main/src/audio_buffer.rs#L10">safety note</a> in the repo.</p>
<p>Anyway, you can see that instead of passing around owned <code>Vec</code>'s as our buffers, we are passing them around via a smart pointer (in this case <a href="https://github.com/glowcoil/basedrop">basedrop</a>'s <code>Shared</code> smart pointer).</p>
<p>I then make them accessible to the user via this safe wrapper (which is not in the repo yet btw):</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#928374;">// Rust
</span><span>
</span><span style="color:#fa5c4b;">pub struct </span><span style="color:#8ec07c;">AudioBufferFormat</span><span>&lt;T&gt;
</span><span>where
</span><span>    T: Sized + Copy + Clone + Send + Default + &#39;static
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// Make this private so the user doesn&#39;t have direct access to this
</span><span>    </span><span style="font-style:italic;color:#928374;">// &quot;unsafe&quot; buffer.
</span><span>    </span><span style="color:#fdf4c1;">rc_buffers</span><span>: SmallVec&lt;[SharedAudioBuffer&lt;T&gt;; </span><span style="color:#d3869b;">2</span><span>]&gt;,
</span><span>}
</span><span>
</span><span style="color:#fa5c4b;">impl</span><span>&lt;T&gt; </span><span style="color:#8ec07c;">AudioBufferFormat</span><span>&lt;T&gt;
</span><span style="color:#fa5c4b;">where
</span><span>    T: Sized + Copy + Clone + Send + Default + </span><span style="color:#fa5c4b;">&#39;static
</span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// ...
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#928374;">/// Immutably borrow a channel.
</span><span>    </span><span style="font-style:italic;color:#928374;">///
</span><span>    </span><span style="font-style:italic;color:#928374;">/// This will return `None` if the channel with the given index does
</span><span>    </span><span style="font-style:italic;color:#928374;">/// not exist.
</span><span>    #[</span><span style="color:#fdf4c1;">inline</span><span>]
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">channel</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>, </span><span style="color:#fdf4c1;">channel</span><span>: </span><span style="color:#fa5c4b;">usize</span><span>, </span><span style="color:#fdf4c1;">proc_info</span><span>: </span><span style="color:#fe8019;">&amp;</span><span>ProcInfo)
</span><span>        -&gt; </span><span style="color:#fabd2f;">Option</span><span>&lt;</span><span style="color:#fe8019;">&amp;</span><span>[T]&gt;
</span><span>    {
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.rc_buffers.</span><span style="color:#fabd2f;">get</span><span>(channel).</span><span style="color:#fabd2f;">map</span><span>(|</span><span style="color:#fdf4c1;">b</span><span>| b.</span><span style="color:#fabd2f;">borrow</span><span>() })
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">/// Mutably borrow a channel.
</span><span>    </span><span style="font-style:italic;color:#928374;">///
</span><span>    </span><span style="font-style:italic;color:#928374;">/// This will return `None` if the channel with the given index does
</span><span>    </span><span style="font-style:italic;color:#928374;">/// not exist.
</span><span>    #[</span><span style="color:#fdf4c1;">inline</span><span>]
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">channel_mut</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut </span><span style="color:#fdf4c1;">self</span><span>, </span><span style="color:#fdf4c1;">channel</span><span>: </span><span style="color:#fa5c4b;">usize</span><span>, </span><span style="color:#fdf4c1;">proc_info</span><span>: </span><span style="color:#fe8019;">&amp;</span><span>ProcInfo)
</span><span>        -&gt; </span><span style="color:#fabd2f;">Option</span><span>&lt;</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut </span><span>[T]&gt;
</span><span>    {
</span><span>        </span><span style="font-style:italic;color:#928374;">// Safety: Mutability rules are upheld because this method borrows
</span><span>        </span><span style="font-style:italic;color:#928374;">// `self` as mutable, preventing the user from borrowing the same
</span><span>        </span><span style="font-style:italic;color:#928374;">// buffer twice.
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.rc_buffers.</span><span style="color:#fabd2f;">get</span><span>(channel).</span><span style="color:#fabd2f;">map</span><span>(|</span><span style="color:#fdf4c1;">b</span><span>| b.</span><span style="color:#fabd2f;">borrow_mut</span><span>() })
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// ... more methods for borrowing more than one channel at once
</span><span>}
</span><span>
</span><span style="color:#fa5c4b;">pub struct </span><span style="color:#8ec07c;">AudioBuffer </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">float</span><span>: </span><span style="color:#fabd2f;">Option</span><span>&lt;AudioBufferFormat&lt;</span><span style="color:#fa5c4b;">f32</span><span>&gt;&gt;,
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">double</span><span>: </span><span style="color:#fabd2f;">Option</span><span>&lt;AudioBufferFormat&lt;</span><span style="color:#fa5c4b;">f64</span><span>&gt;&gt;,
</span><span>
</span><span>    </span><span style="font-style:italic;color:#928374;">// Make these private so the user can&#39;t modify them.
</span><span>    </span><span style="color:#fdf4c1;">latency</span><span>: </span><span style="color:#fa5c4b;">u32</span><span>,     </span><span style="font-style:italic;color:#928374;">// latency from/to the audio interface
</span><span>    </span><span style="color:#fdf4c1;">silent_mask</span><span>: </span><span style="color:#fa5c4b;">u64</span><span>, </span><span style="font-style:italic;color:#928374;">// mask &amp; (1 &lt;&lt; N) to test if channel N is silent
</span><span>    </span><span style="color:#fdf4c1;">channel_count</span><span>: </span><span style="color:#fa5c4b;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#fa5c4b;">impl </span><span style="color:#8ec07c;">AudioBuffer </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">latency</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>) -&gt; </span><span style="color:#fa5c4b;">u32 </span><span>{
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.latency
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">silent_mask</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>) -&gt; </span><span style="color:#fa5c4b;">u64 </span><span>{
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.silent_mask
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">channel_count</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>) -&gt; </span><span style="color:#fa5c4b;">usize </span><span>{
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.channel_count
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#928374;">// And finally, this is what gets passed into the plugin&#39;s `process()`
</span><span style="font-style:italic;color:#928374;">// method:
</span><span>
</span><span style="color:#fa5c4b;">pub struct </span><span style="color:#8ec07c;">ProcAudioBuffers</span><span>&lt;</span><span style="color:#fa5c4b;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">inputs</span><span>: </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">&#39;a</span><span> [</span><span style="color:#fabd2f;">Option</span><span>&lt;AudioBuffer&gt;&gt;],
</span><span>    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">outputs</span><span>: </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">&#39;a mut</span><span> [AudioBuffer],
</span><span>}
</span></code></pre>
<h1 id="to-be-continued">To be continued</h1>
<hr />
<p>This post showed how you can pass audio buffers from a Rust host to an internal Rust plugin. Next up I'll show how this audio buffer API can be used to make safe <a href="https://github.com/free-audio/clap">CLAP</a> plugins (and possibly other plugin formats) in Rust, making it so you can use the same code for both an internal plugin in my DAW engine as well as an external CLAP plugin.</p>
<h1 id="addendum">Addendum</h1>
<hr />
<p>I've learned that writing blogs really helps with working through a problem. I'm excited to do this more often!</p>

</article>

    </main>
    
    <footer>
        
        &copy; 2024 Billy Messenger
        
        
        Â· Powered by <a href="https://www.getzola.org/">Zola</a> and <a href="https://github.com/tarunjana/simplify/">Simplify</a>
        
    </footer>
</body>

</html>