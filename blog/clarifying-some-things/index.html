<!DOCTYPE html>
<html lang="en">

<head>
    
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
<title>Clarifying Some Things, and What I&#x27;m Doing Now - Billy Messenger</title>

    
    <link rel="stylesheet" href="/css/simple.min.css">
    
    
<style>
.toc {
    margin-bottom: 3rem;
}
</style>

    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <link rel="alternate" type="application/atom+xml" title="Atom Feed for billydm.github.io" href="/atom.xml" />
    <link rel="preconnect" href="https://api.fonts.coollabs.io" crossorigin>
    <link href="https://api.fonts.coollabs.io/css2?family=Inter&display=swap" rel="stylesheet">
    <link href="https://api.fonts.coollabs.io/css2?family=Fira+Code&display=swap" rel="stylesheet">
    
    
    
    
</head>

<body>
    <header>
        
        <nav>
            
            <a href="&#x2F;">Home</a>
            
            <a href="&#x2F;blog&#x2F;">Blog</a>
            
            <a href="&#x2F;categories&#x2F;">Categories</a>
            
            <a href="&#x2F;atom.xml">Feed</a>
            
            <a href="https:&#x2F;&#x2F;github.com&#x2F;BillyDM">Github</a>
            
        </nav>
        
        
<h1>Clarifying Some Things, and What I&#x27;m Doing Now</h1>

    </header>
    
    <main>
        
<article>
    
    <em>Published on: <time>16 May 2023</time></em>
    
    
    <h2>Table of Contents</h2>
    <ul class="toc">
        
        <li>
            <a href="https://billydm.github.io/blog/clarifying-some-things/#preface">Preface</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/clarifying-some-things/#clarifications">Clarifications</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/clarifying-some-things/#sparking-discussion-on-rust-guis">Sparking Discussion on Rust GUIs</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/clarifying-some-things/#gui-is-hard">GUI is Hard</a>
            
            <ul>
                
                <li>
                    <a href="https://billydm.github.io/blog/clarifying-some-things/#edit">Edit:</a>
                </li>
                
            </ul>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/clarifying-some-things/#what-i-learned-about-open-source">What I Learned About Open Source</a>
            
        </li>
        
        <li>
            <a href="https://billydm.github.io/blog/clarifying-some-things/#what-i-m-doing-now">What I&#x27;m Doing Now</a>
            
        </li>
        
    </ul>
    
    
    <h1 id="preface">Preface</h1>
<hr />
<p>Welp, apparently one of my previous posts <a href="../daw-frontend-development-struggles">DAW Frontend Development Struggles</a> is trending on Hacker News and the Rust subreddit. Couldn't have come at a more awkward time.</p>
<p>I want to take this time to clarify some things, as well as what my current plans for Meadowlark are. Some of my opinions have changed somewhat since that post.</p>
<h1 id="clarifications">Clarifications</h1>
<hr />
<p>I want to clarify that I do think a fully-featured GUI library in Rust is possible, it's just that it's still a few years away.</p>
<p>Also I want to state that my complications have more to do with the fact that I'm writing a complicated DAW GUI and not a typical application. Existing Rust GUI libraries are already (mostly) competent at this.</p>
<p>And yeah, I was maybe a bit quick to dismiss <a href="https://slint-ui.com/">slint</a> and <a href="https://github.com/makepad/makepad">makepad</a> in my post. I now have a different reason for not going with those which I'll explain below, but I don't want to downplay the potential of these projects (and also projects like <a href="https://github.com/vizia/vizia">vizia</a> and <a href="https://github.com/iced-rs/iced">iced</a>).</p>
<p>I now think declarative is probably possible to use for something as complex as a DAW (although it's still more cumbersome IMO). Immediate mode might also work if executed correctly.</p>
<p>The <a href="https://github.com/linebender/xilem">xilem</a> architecture also seems very promising in solving a lot of the problems that a GUI library in Rust has. But of course it's just an experiment at the moment.</p>
<p>Also my opinion on the importance of damage-tracking has changed somewhat. I no longer think it's <em>that</em> important in the advent of modern GPUs. But I do still think that more consideration should be given to minimizing the work being done on the GPU.</p>
<h1 id="sparking-discussion-on-rust-guis">Sparking Discussion on Rust GUIs</h1>
<hr />
<p>That being said, I think the original opinions I had in my previous post illustrate an important point.</p>
<p>It goes to show that a lot of work and careful considerations are needed if we ever want a truly general purpose Rust GUI toolkit to take over. I'm sure I'm not the only one who has been frustrated by the state of the Rust GUI ecosystem.</p>
<h1 id="gui-is-hard">GUI is <em>Hard</em></h1>
<hr />
<p>I can't stress this point enough. There's so much more to GUI than meets the eye.</p>
<h3 id="edit">Edit:</h3>
<p>Now while that point still stands, I think I was being unfair with my previous edit.</p>
<p>There's a lot of "one man" Rust GUI libraries out there. There's nothing wrong with that, and they can already be used for a wide variety of applications. I think most if not all these projects aren't actually trying to directly compete with the likes of QT, JUCE, GTK, Flutter, Electron, etc. They are aiming to be a solution for a different problem, and I believe they are achieving that very well.</p>
<p>My personal favorite is <a href="https://github.com/emilk/egui">egui</a>, it makes it so easy to whip up prototypes, and the performance isn't bad either.</p>
<p>With that out of the way, I still want to give you my list from the previous edit. The point I'm now making is that if the goal of a particular Rust GUI library <em>is</em> to compete in the big leagues, there are a lot of complicated hidden details that must be addressed. While not every one of these features need to be included, I think it gives a good overall idea of the complexity we're dealing with here.</p>
<p>Some of these features include:</p>
<ul>
<li>Extensive documentation, examples, and tutorials (hello worlds and 7GUIs alone aren't enough)</li>
<li>Accessibility features. This one is hard to get right.</li>
<li>Proper unicode text support. Even better if it has support for inline styling. This one is <em>very</em> hard to get right.</li>
<li>Text that looks sharp even at small sizes. I say this because a lot of Rust GUI libraries currently use GPU-based text rendering which doesn't look very good.</li>
<li>Built-in features to help with localization</li>
<li>Support to easily use custom icons</li>
<li>Proper multi-window support (this is harder than you might think)</li>
<li>Proper drag-and-drop support. This includes both internal drag-and-drop, and drag-and-drop from the OS.</li>
<li>Proper touch support. Even if you aren't targeting mobile, users with touchscreen laptops and tablets will still expect touch to work.</li>
<li>Flexible state management and widget composition. Real-world applications commonly have unusual requirements and edge cases, and so the user shouldn't be locked into one way of doing things. This one is more a matter of opinion though, and it may be possible to create an API that covers most if not all use cases.</li>
<li>Features that allow the user to better optimize the performance of their UI. Don't leave optimizations decisions purely up to the UI engine.</li>
<li>Proper support for drawing custom widgets. This includes the ability to draw more complicated shapes like arcs and Bézier curves. These complex shapes don't always need to be GPU-accelerated, but they need to be possible. A common use case to be aware of is interactive graphs and plots.</li>
<li>Support for custom shaders (along with the ability to draw widgets on top of the shader area). People will want this. This is also now more complicated because Apple is getting rid of support for OpenGL. You now need to support Metal as well. This will also be needed if you want to support video playback.</li>
<li>If using immediate mode, make sure to use a lot of caching techniques to meet performance demands when scaled to large project sizes (or even use retained-mode under the hood).</li>
<li>If not using damage tracking for rendering, give careful consideration on how to optimize, minimize, and cache the commands that are sent to the GPU.</li>
<li>If using a declarative API, make sure that it's possible to declare the UI in code rather than a markup language (and have documentation and examples for how to do this). Not everyone likes using the markup language approach.</li>
<li>Fast incremental compiles (or even better, hot-reloading)</li>
<li>Support for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">pointer locking</a>. Well ok, this is a pretty niche feature, but let me tell you if you do need it it really sucks if the UI library doesn't support it.</li>
<li>Bindings to other languages (especially a scripting language like Python or <del>Javascript</del> Typescript). This alone will make the project accessible to a <em>lot</em> more people.</li>
<li>Detailed unicode text editing (single-line and multi-line). This is <em>very</em> hard to get right.</li>
<li>Ability to click links in user-generated text</li>
<li>Support for a variety of image formats, including SVG and GIF</li>
<li>Loading placeholders for images and other content that is being downloaded</li>
<li>Ability to play sound effects (although this one could be handled by a separate crate)</li>
<li>Ability to playback videos (offline and streaming). This should also include control overlays.</li>
<li>Integration with native menubars and other window controls</li>
<li>Support for borderless windows</li>
<li>Integration with native dialogs such as file dialogs and print dialogs</li>
<li>Integration with OS notifications and media controls</li>
<li>Proper password input, as well as integration with the OS's keychain</li>
<li>Support for custom keyboard shortcuts, along with the ability to change those shortcuts at runtime</li>
<li>Kinetic scrolling for touch screens (although this probably isn't that necessary unless you're targeting mobile)</li>
<li>Infinitely scrolling lists (very hard to get right)</li>
<li>Ability to move panels using drag-and-drop, as well as the ability to pop-out panels into a floating window</li>
<li>Support for custom layouts for things like node editors</li>
<li>Animation support</li>
<li>Nested drop-down menus, as well as the ability to scroll drop-downs that are taller than the screen.</li>
<li>Proper nested tree widget</li>
<li>Proper table widget</li>
<li>Some more advanced widgets like calendars, color selectors, and emoji input dialogs (although these could be handled by third-party extensions)</li>
<li>Also don't forget to include any of the essential widgets. These lists of built-in widgets in <a href="https://docs.gtk.org/gtk3/visual_index.html">GTk3</a> and <a href="https://docs.gtk.org/gtk4/visual_index.html">GTK4</a> can give you a good idea.</li>
</ul>
<blockquote>
<p>JUCE doesn't actually have a lot of these features. Its focus is on audio software, and not general use. Existing Rust libraries like <a href="https://github.com/vizia/vizia">vizia</a>, <a href="https://github.com/iced-rs/iced">iced</a>, and <a href="https://github.com/emilk/egui">egui</a> are already quite competent at the audio plugin use case (which is the majority of JUCE's user base).</p>
<p>The <a href="https://github.com/audulus/rui">rui</a> library also seems promising for this use case since it is specifically being used for a commercial audio application. Though I'm not sure anyone has actually tried to make an audio plugin with it yet.</p>
</blockquote>
<h1 id="what-i-learned-about-open-source">What I Learned About Open Source</h1>
<hr />
<p>I learned a very important lesson from my struggles. Not just my struggles with the UI, but with Meadowlark itself.</p>
<p>You can't rely on volunteers to build key components of a large open source project. Unless you have found someone else who is as passionate as you are, has the same vision as you do, and has as much free time as you do (or unless you're running a business with employees), you must be prepared that you will be working on it alone for a <em>long</em> time. You must be prepared that you will do the vast majority of the work yourself. You also need to understand your limits as a solo developer (which is something I previously grossly miscalculated).</p>
<h1 id="what-i-m-doing-now">What I'm Doing Now</h1>
<hr />
<p>I learned that I simply cannot make both a DAW engine and a DAW frontend on my own. I severely underestimated the frontend. I'm only one person.</p>
<p>But that's ok, because I actually have found someone else who is working on their own DAW frontend, and they are very good at it. By coincidence (or maybe it's fate?), they share a similar vision to what I had with Meadowlark's UI. So we decided to team up, with them working on the frontend and me working on the backend engine.</p>
<p>They're using Flutter, and it's impressive what they were able to do with it. So Meadowlark (or whatever we end up calling it) will use Flutter for mainly that reason.</p>
<p>They were originally going to use the <a href="https://www.tracktion.com/develop/tracktion-engine">Tracktion Engine</a> for the backend, but they agreed that having a new open source engine would be beneficial.</p>
<p>And so here's what I'm doing now: I'm creating my own DAW engine like Tracktion's, but with these notable advantages:</p>
<ul>
<li>Modular ecosystem: you only need to include the parts of the engine you use</li>
<li>Good documentation</li>
<li>Written in Rust, with all the safety advantages that brings</li>
<li>Zero dependencies on JUCE</li>
<li>Full first-class support for all of <a href="https://github.com/free-audio/clap">CLAP</a>'s features, allowing for some exciting new ways to use plugins</li>
<li>Better control over the engine: it doesn't force you to use a certain workflow</li>
<li>Additional bindings to C and C++</li>
<li><em>Maybe</em> MIT license? I haven't decided on that yet.</li>
</ul>
<p>Maybe I might even try monetizing the engine in some way. Whether that be dual-licensing or sponsorships, I haven't decided yet.</p>
<p>This DAW engine will be called <a href="https://github.com/MeadowlarkDAW/dropseed">Dropseed</a> (following the naming scheme I have of native fauna and flora in Kansas. Dropseed is the name of a grass).</p>
<p>I'm also creating an FL Studio Patcher-like plugin as a testbed for my engine. I eventually want to have a Patcher-like plugin in Meadowlark anyway, so it's still a good use of my time.</p>
<blockquote>
<p>BTW, I'm not going to mention who this person is or what project they were working on yet. I don't want to drive unwanted attention towards them.</p>
</blockquote>

</article>

    </main>
    
    <footer>
        
        &copy; 2024 Billy Messenger
        
        
        · Powered by <a href="https://www.getzola.org/">Zola</a> and <a href="https://github.com/tarunjana/simplify/">Simplify</a>
        
    </footer>
</body>

</html>